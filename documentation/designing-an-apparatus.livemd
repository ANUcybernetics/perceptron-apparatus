# Apparatus v2 Design

```elixir
Mix.install([
  {:kino, "~> 0.12.0"},
  {:math, "~> 0.7"}
])
```

## Setup

```elixir
svg_wrapper = fn body, view_box ->
  """
  <svg viewBox="#{view_box}" stroke="black" fill="transparent" stroke-width="1" xmlns="http://www.w3.org/2000/svg">
    <style>
    svg {
      font-family: Garamond;
    }
    </style>
    #{body}
  </svg>
  """
end

svg_kino = fn body, view_box ->
  svg_wrapper.(body, view_box)
  |> Kino.HTML.new()
end

disk_kino = fn body ->
  svg_kino.(~s|<circle cx="0" cy="0" r="400" stroke-width="2"/>| <> body, "-400 -400 800 800")
end

disk_file = fn body, path ->
  content =
    svg_wrapper.(
      ~s|<circle cx="0" cy="0" r="400" stroke-width="2"/>| <> body,
      "-400 -400 800 800"
    )

  File.write!(path, content)
end
```

## Rotating rings

```elixir
rotating_ring = fn r, outer_scale, inner_scale ->
  outer_ticks =
    outer_scale
    |> Enum.map(fn {pos, label} ->
      """
        <g transform="rotate(#{-pos})" transform-origin="0 0">
          <text x="0" y="#{r + 20}" style="font-size: 10px;" fill="black" stroke="none" text-anchor="middle" dominant-baseline="auto">#{label}</text>
          <line x1="0" y1="#{r}" x2="0" y2="#{if label != "", do: r + 8, else: r + 4}" />
        </g>
      """
    end)

  inner_ticks =
    inner_scale
    |> Enum.map(fn {pos, label} ->
      """
        <g transform="rotate(#{-pos})" transform-origin="0 0">
          <text x="0" y="#{r - 20}" style="font-size: 10px;" fill="black" stroke="none" text-anchor="middle" dominant-baseline="hanging">#{label}</text>
          <line x1="0" y1="#{if label != "", do: r - 8, else: r - 4}" x2="0" y2="#{r}" />
        </g>
      """
    end)

  Enum.join([
    ~s|<circle cx="0" ch="0" r="#{r}" stroke="red" />|,
    outer_ticks,
    inner_ticks
  ])
end
```

```elixir
log_scale =
  10..99
  |> Enum.map(fn x ->
    pos = (Math.log(x / 10.0) - Math.log(1.0)) / (Math.log(10.0) - Math.log(1.0)) * 360.0

    cond do
      x <= 20 -> {pos, Float.to_string(x / 10.0)}
      Integer.mod(x, 2) == 0 && x <= 50 -> {pos, Float.to_string(x / 10.0)}
      Integer.mod(x, 5) == 0 && x > 50 -> {pos, Float.to_string(x / 10.0)}
      true -> {pos, ""}
    end
  end)

relu_outer =
  -180..179//3
  |> Enum.map(fn x ->
    cond do
      Integer.mod(x, 5) == 0 -> {x, Float.to_string(x / 30.0)}
      true -> {x, ""}
    end
  end)

relu_inner =
  -180..179//3
  |> Enum.map(fn x ->
    cond do
      x <= 0 && Integer.mod(x, 5) == 0 -> {x, "0"}
      Integer.mod(x, 5) == 0 -> {x, Float.to_string(x / 30.0)}
      true -> {x, ""}
    end
  end)

log_ring = rotating_ring.(370, log_scale, log_scale)
activation_ring = rotating_ring.(310, relu_outer, relu_inner)

disk_kino.(log_ring <> activation_ring)
```

## Radial sliders

```elixir
radial_slider = fn r_inner, r_outer, theta ->
  length = r_outer - r_inner

  labels =
    0..10
    |> Enum.map(fn x ->
      y = length - (2 + x * (length - 4) / 10.0)

      label =
        cond do
          Integer.mod(x, 5) == 0 -> Integer.to_string(x)
          true -> ""
        end

      """
        <line x1="-3"  y1="#{y}"  x2="3" y2="#{y}" stroke-width="0.3" />
        <text x="0" y="#{y}"
              style="font-size: 5px;" fill="black" stroke="none" stroke-width="0.3"
              text-anchor="middle" dominant-baseline="middle"
              >#{label}</text>
      """
    end)
    |> Enum.join()

  """
  <g transform="rotate(#{theta}) translate(0 #{r_inner})"  transform-origin="0 0">
   <path
    d="M -3 0
      a 3 3 0 0 1 6 0
      v #{length}
      a 3 3 0 0 1 -6 0
      v #{-length}"
    stroke="red"
    />
    #{labels}
    </g>
  """
end

svg_kino.(radial_slider.(150, 250, 0), "-100 140 200 120")
```

```elixir
radial_slider_group = fn r_inner, r_outer, n_sliders, d_theta, offset_theta ->
  0..(n_sliders - 1)
  |> Enum.map(fn x -> radial_slider.(r_inner, r_outer, offset_theta + x * d_theta) end)
  |> Enum.join()
end

radial_slider_ring = fn r_inner, r_outer, n_groups, sliders_per_group ->
  d_theta =
    case n_groups do
      1 -> 360 / (sliders_per_group * n_groups)
      _ -> 360 / ((sliders_per_group + 1) * n_groups)
    end

  0..(n_groups - 1)
  |> Enum.map(fn x ->
    radial_slider_group.(r_inner, r_outer, sliders_per_group, d_theta, 360 * x / n_groups)
  end)
  |> Enum.join()
end

hidden_1_ring = radial_slider_ring.(200, 300, 5, 25)
hidden_2_ring = radial_slider_ring.(80, 160, 10, 5)
disk_kino.(hidden_1_ring <> hidden_2_ring)
```

## Azimuthal sliders

```elixir
azimuthal_slider = fn r, theta, theta_offset ->
  labels =
    0..10
    |> Enum.map(fn val ->
      label =
        cond do
          Integer.mod(val, 2) == 0 -> Integer.to_string(val)
          true -> ""
        end

      """
      <g transform="rotate(#{-theta * val / 10.0})"  transform-origin="0 0">
        <line x1="0" y1="#{r + 3}" x2="0" y2="#{r + 6}" />
        <text x="0" y="#{r + 10}"
              style="font-size: 7px;" fill="black" stroke="none" stroke-width="0.3"
              text-anchor="middle" dominant-baseline="middle"
              >#{label}</text>
      </g>
      """
    end)
    |> Enum.join()

  x1 = 0
  y1 = r - 3
  x2 = 0
  y2 = r + 3
  x3 = (r + 3) * Math.sin(Math.deg2rad(theta))
  y3 = (r + 3) * Math.cos(Math.deg2rad(theta))
  x4 = (r - 3) * Math.sin(Math.deg2rad(theta))
  y4 = (r - 3) * Math.cos(Math.deg2rad(theta))

  """
  <g transform="rotate(#{-theta_offset})"  transform-origin="0 0">
   <path
    d="M #{x1} #{y1}
      A 3 3 0 0 0 #{x2} #{y2}
      A #{r + 3} #{r + 3} 0 0 0 #{x3} #{y3}
      A 3 3 0 0 0 #{x4} #{y4}
      A #{r - 3} #{r - 3} 0 0 1 #{x1} #{y1}"
    stroke="red"
    />
    #{labels}
    </g>
  """
end

svg_kino.(azimuthal_slider.(150, 45, 0), "-20 80 160 100")
```

```elixir
azimuthal_slider_ring = fn r, n_sliders ->
  0..(n_sliders - 1)
  |> Enum.map(fn val ->
    azimuthal_slider.(r, 0.8 * 360 / n_sliders, 360 * val / n_sliders)
  end)
  |> Enum.join()
end

disk_kino.(azimuthal_slider_ring.(200, 5))
```

## Putting it all together

```elixir
all_rings =
  Enum.join([
    azimuthal_slider_ring.(380, 25),
    rotating_ring.(350, log_scale, log_scale),
    rotating_ring.(300, relu_outer, relu_inner),
    radial_slider_ring.(190, 270, 4, 25),
    azimuthal_slider_ring.(160, 4),
    radial_slider_ring.(95, 145, 10, 4),
    radial_slider_ring.(25, 80, 1, 10)
    # azimuthal_slider_ring.(70, 10)
  ])

disk_file.(all_rings, "/tmp/apparatus-v2.svg")
disk_kino.(all_rings)
```

## HEEx testing

```elixir
import Phoenix.Component, only: [sigil_H: 2]

test_component = fn assigns ->
  ~H"""
  <p>Hi <%= @name %>.</p>
  """
end

test_component.(%{name: "Mum"})
|> Phoenix.HTML.Safe.to_iodata()
|> Enum.join()
```
