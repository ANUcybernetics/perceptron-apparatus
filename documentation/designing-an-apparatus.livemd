# Designing a Perceptron Apparatus

```elixir
Mix.install([
  {:perceptron_apparatus, path: "~/Documents/edex/human-scale-ai/perceptron_apparatus"}
])

alias PerceptronApparatus, as: PA
alias PerceptronApparatus.Rings
```

## Setup

```elixir
log_ring = Rings.SlideRule.log_rule() |> Rings.SlideRule.new()
relu_ring = Rings.SlideRule.relu_rule(10, 0.25) |> Rings.SlideRule.new()

input_ring = Rings.AzimuthalSliders.new({25})
w1_ring = Rings.RadialSliders.new({5, 25})
h1_ring = Rings.AzimuthalSliders.new({5})
w2_ring = Rings.RadialSliders.new({10, 5}, width: 60)
# output_ring = Rings.AzimuthalSliders.new({10})
output_ring = Rings.RadialSliders.new({10, 1}, width: 80)

PA.new(1200)
|> PA.add_ring(log_ring)
|> PA.add_ring(relu_ring)
|> PA.add_ring(input_ring)
|> PA.add_ring(w1_ring)
|> PA.add_ring(h1_ring)
|> PA.add_ring(w2_ring)
|> PA.add_ring(output_ring)
|> PA.render()
|> tap(fn data -> File.write!("/tmp/apparatus-v2.svg", data) end)
|> Kino.HTML.new()

# # PerceptronApparatus.Rings.RadialSliders.render_group(600, 200, 9, 30, 10)
# PerceptronApparatus.Rings.RadialSliders.render_guides(600, 300, 5, 0..10)
# |> PerceptronApparatus.Utils.wrap_in_svg("-600 -600 1200 1200")
# |> Kino.HTML.new()
```

```elixir
PerceptronApparatus.new(1200)
|> PerceptronApparatus.render()
|> Kino.HTML.new()
```

## Radial sliders

```elixir
radial_slider_group = fn r_inner, r_outer, n_sliders, d_theta, offset_theta ->
  0..(n_sliders - 1)
  |> Enum.map(fn x -> radial_slider.(r_inner, r_outer, offset_theta + x * d_theta) end)
  |> Enum.join()
end

radial_slider_ring = fn r_inner, r_outer, n_groups, sliders_per_group ->
  d_theta =
    case n_groups do
      1 -> 360 / (sliders_per_group * n_groups)
      _ -> 360 / ((sliders_per_group + 1) * n_groups)
    end

  0..(n_groups - 1)
  |> Enum.map(fn x ->
    radial_slider_group.(r_inner, r_outer, sliders_per_group, d_theta, 360 * x / n_groups)
  end)
  |> Enum.join()
end

hidden_1_ring = radial_slider_ring.(200, 300, 5, 25)
hidden_2_ring = radial_slider_ring.(80, 160, 10, 5)
disk_kino.(hidden_1_ring <> hidden_2_ring)
```

## Slide rules

```elixir
PerceptronApparatus.Rings.SlideRule.relu_inner()
```

```elixir
krotating_ring = fn r, outer_scale, inner_scale ->
  outer_ticks =
    outer_scale
    |> Enum.map(fn {pos, label} ->
      """
        <g transform="rotate(#{-pos})" transform-origin="0 0">
          <text x="0" y="#{r + 20}" style="font-size: 10px;" fill="black" stroke="none" text-anchor="middle" dominant-baseline="auto">#{label}</text>
          <line x1="0" y1="#{r}" x2="0" y2="#{if label != "", do: r + 8, else: r + 4}" />
        </g>
      """
    end)

  inner_ticks =
    inner_scale
    |> Enum.map(fn {pos, label} ->
      """
        <g transform="rotate(#{-pos})" transform-origin="0 0">
          <text x="0" y="#{r - 20}" style="font-size: 10px;" fill="black" stroke="none" text-anchor="middle" dominant-baseline="hanging">#{label}</text>
          <line x1="0" y1="#{if label != "", do: r - 8, else: r - 4}" x2="0" y2="#{r}" />
        </g>
      """
    end)

  Enum.join([
    ~s|<circle cx="0" ch="0" r="#{r}" stroke="red" />|,
    outer_ticks,
    inner_ticks
  ])
end
```

```elixir
log_scale =
  10..99
  |> Enum.map(fn x ->
    pos = (Math.log(x / 10.0) - Math.log(1.0)) / (Math.log(10.0) - Math.log(1.0)) * 360.0

    cond do
      x <= 20 -> {pos, Float.to_string(x / 10.0)}
      Integer.mod(x, 2) == 0 && x <= 50 -> {pos, Float.to_string(x / 10.0)}
      Integer.mod(x, 5) == 0 && x > 50 -> {pos, Float.to_string(x / 10.0)}
      true -> {pos, ""}
    end
  end)

relu_outer =
  -180..179//3
  |> Enum.map(fn x ->
    cond do
      Integer.mod(x, 5) == 0 -> {x, Float.to_string(x / 30.0)}
      true -> {x, ""}
    end
  end)

relu_inner =
  -180..179//3
  |> Enum.map(fn x ->
    cond do
      x <= 0 && Integer.mod(x, 5) == 0 -> {x, "0"}
      Integer.mod(x, 5) == 0 -> {x, Float.to_string(x / 30.0)}
      true -> {x, ""}
    end
  end)

log_ring = rotating_ring.(370, log_scale, log_scale)
activation_ring = rotating_ring.(310, relu_outer, relu_inner)

disk_kino.(log_ring <> activation_ring)
```

## Azimuthal sliders

```elixir
azimuthal_slider = fn r, theta, theta_offset ->
  labels =
    0..10
    |> Enum.map(fn val ->
      label =
        cond do
          Integer.mod(val, 2) == 0 -> Integer.to_string(val)
          true -> ""
        end

      """
      <g transform="rotate(#{-theta * val / 10.0})"  transform-origin="0 0">
        <line x1="0" y1="#{r + 3}" x2="0" y2="#{r + 6}" />
        <text x="0" y="#{r + 10}"
              style="font-size: 7px;" fill="black" stroke="none" stroke-width="0.3"
              text-anchor="middle" dominant-baseline="middle"
              >#{label}</text>
      </g>
      """
    end)
    |> Enum.join()

  x1 = 0
  y1 = r - 3
  x2 = 0
  y2 = r + 3
  x3 = (r + 3) * Math.sin(Math.deg2rad(theta))
  y3 = (r + 3) * Math.cos(Math.deg2rad(theta))
  x4 = (r - 3) * Math.sin(Math.deg2rad(theta))
  y4 = (r - 3) * Math.cos(Math.deg2rad(theta))

  """
  <g transform="rotate(#{-theta_offset})"  transform-origin="0 0">
   <path
    d="M #{x1} #{y1}
      A 3 3 0 0 0 #{x2} #{y2}
      A #{r + 3} #{r + 3} 0 0 0 #{x3} #{y3}
      A 3 3 0 0 0 #{x4} #{y4}
      A #{r - 3} #{r - 3} 0 0 1 #{x1} #{y1}"
    stroke="red"
    />
    #{labels}
    </g>
  """
end

svg_kino.(azimuthal_slider.(150, 45, 0), "-20 80 160 100")
```

```elixir
azimuthal_slider_ring = fn r, n_sliders ->
  0..(n_sliders - 1)
  |> Enum.map(fn val ->
    azimuthal_slider.(r, 0.8 * 360 / n_sliders, 360 * val / n_sliders)
  end)
  |> Enum.join()
end

disk_kino.(azimuthal_slider_ring.(200, 5))
```

## Putting it all together

```elixir
all_rings =
  Enum.join([
    azimuthal_slider_ring.(380, 25),
    rotating_ring.(350, log_scale, log_scale),
    rotating_ring.(300, relu_outer, relu_inner),
    radial_slider_ring.(190, 270, 4, 25),
    azimuthal_slider_ring.(160, 4),
    radial_slider_ring.(95, 145, 10, 4),
    radial_slider_ring.(25, 80, 1, 10)
    # azimuthal_slider_ring.(70, 10)
  ])

disk_file.(all_rings, "/tmp/apparatus-v2.svg")
disk_kino.(all_rings)
```

## HEEx testing

```elixir
import Phoenix.Component, only: [sigil_H: 2]

test_component = fn assigns ->
  ~H"""
  <p>Hi <%= @name %>.</p>
  """
end

test_component.(%{name: "Mum"})
|> Phoenix.HTML.Safe.to_iodata()
|> Enum.join()
```
